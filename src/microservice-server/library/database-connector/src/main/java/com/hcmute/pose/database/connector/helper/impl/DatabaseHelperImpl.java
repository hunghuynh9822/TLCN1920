package com.hcmute.pose.database.connector.helper.impl;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.hcmute.pose.database.connector.DataSource;
import com.hcmute.pose.database.connector.exception.TransactionException;
import com.hcmute.pose.database.connector.helper.DatabaseHelper;
import com.hcmute.pose.database.connector.helper.Transaction;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.Serializable;
import java.sql.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseHelperImpl implements DatabaseHelper {
    private static Logger LOGGER = LoggerFactory.getLogger(DatabaseHelperImpl.class);
    private DataSource dataSource;
    private ConcurrentHashMap<Long, Transaction> transactions;

    @Autowired
    public DatabaseHelperImpl(DataSource dataSource){
        this.dataSource = dataSource;
        transactions = new ConcurrentHashMap<>();
    }

    @Override
    public <T extends Serializable> Optional<T> executeQueryObject(Class<T> target,String sql, Object... args) throws SQLException {
        Connection conn = this.dataSource.getConnection();
        try(PreparedStatement ps = conn.prepareStatement(sql)){
            for (int i = 0; i < args.length; i++){
                ps.setObject(i+1,args[i]);
            }
            ResultSet rs = ps.executeQuery();
            return toObject(convertResultSetToHashMap(rs),target);
        }
    }

    @Override
    public <T extends Serializable> List<T> executeQueryListObject(Class<T[]> target,String sql, Object... args) throws SQLException {
        Connection conn = this.dataSource.getConnection();
        try( PreparedStatement ps = conn.prepareStatement(sql)){
            for (int i = 0; i < args.length; i++){
                ps.setObject(i+1,args[i]);
            }
            ResultSet rs = ps.executeQuery();
            return toListObject(convertResultSetToListHashMap(rs),target);
        }
    }

    @Override
    public void beginTransaction(){
        Long threadId = Thread.currentThread().getId();
        Transaction trans = new Transaction(dataSource);
        transactions.put(threadId,trans);
    }

    @Override
    public void executeNonQuery(String sql, Object... args) throws SQLException, TransactionException {
        getTransaction().execute(sql, args);
    }

    @Override
    public void executeNonQuery(String sql,Integer autoGeneratedKeys, Object... args) throws TransactionException, SQLException {
        getTransaction().execute(sql,autoGeneratedKeys, args);
    }

    private Transaction getTransaction() throws TransactionException {
        Long threadId = Thread.currentThread().getId();
        if(transactions.containsKey(threadId)){
            return transactions.get(threadId);
        }
        throw new TransactionException("No transaction exists");
    }

    private void removeTransaction(){
        transactions.remove(Thread.currentThread().getId());
    }

    @Override
    public void commit() throws SQLException, TransactionException {
        LOGGER.info("[DatabaseHelperImpl] COMMITTING...");
        getTransaction().commit();
        removeTransaction();
        LOGGER.info("[DatabaseHelperImpl] COMMIT SUCCESS");
    }

    @Override
    public void closeConnection(){
        this.dataSource.closeConnection();
    }

    private HashMap<String,Object> convertResultSetToHashMap(ResultSet rs) throws SQLException {
        ResultSetMetaData md = rs.getMetaData();
        int columns = md.getColumnCount();
        if(rs != null && rs.next()){
            HashMap<String,Object> row = new HashMap<>();
            for(int i=1; i<=columns; ++i){
                row.put(md.getColumnName(i),rs.getObject(i));
            }
            return row;
        }
        LOGGER.error("[DatabaseHelperImpl]:[convertResultSetToHashMap]: No result");
        return null;
    }

    private <T extends Serializable> Optional<T> toObject(HashMap<String,Object> data,Class<T> target){
        if(data == null){
            return Optional.empty();
        }
        Gson gson = new Gson();
        String json = gson.toJson(data);
        T object = gson.fromJson(json,target);
        return Optional.of(object);
    }

    private List<HashMap<String,Object>> convertResultSetToListHashMap(ResultSet rs) throws SQLException {
        ResultSetMetaData md = rs.getMetaData();
        int columns = md.getColumnCount();
        List<HashMap<String,Object>> listObjects = new ArrayList<>();
        while (rs.next()){
            HashMap<String,Object> row = new HashMap<>();
            for(int i=1; i<=columns; ++i){
                row.put(md.getColumnName(i),rs.getObject(i));
            }
            listObjects.add(row);
        }
        return listObjects;
    }

    private <T extends Serializable> List<T> toListObject(List<HashMap<String,Object>> data,Class<T[]> target){
        Gson gson = new Gson();
        String json = gson.toJson(data);
        T[] arrays = gson.fromJson(json,target);
        List<T> list = Arrays.asList(arrays);
        return list;
    }
}
